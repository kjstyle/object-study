## 1장. 객체 설계
* 모든 소프트웨어에는 3가지 목적
    * 제대로 실행되는 것
    * 변경을 위해 존재하는 것
    * 코드를 읽는 사람과 의사소통하는 것
* 문제점
    * 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재
    * 세부적인 내용들을 한꺼번에 기억하고 있어야한다는 점
        * Audience가 Bag을 가지고있고, Bag안에는 현금(amount)과 티켓(ticket)이 들어있으며, TicketSeller가 TicketOffice에서 TIcket을 판매하고, TicketOffice안에 돈과 ticket이 보관돼 있다는 모든 사실을 동시에 기억해야만 함 -> 복잡하고 어려움
    * 변경에 취약한 코드
        * 만약 TicketOffice밖의 TicketSeller가 Ticket을 판매해야한다면?
        * 만약 Audience가 Bag이 없다면?
        * 만약 Audience가 현금이나 Invitation이 아닌 신용카드로 결제한다고하면?
        * 하나의 수정이 연결되어있는 상당수의 클래스의 변경이 발생해버림
            * 높은 결합도(coupling)
* (step2) 첫번째 개선
    * (기존문제)Theater가 Audience와 TicketSeller뿐 이나라 Audience소유의 Bag과 TicketSeller가 근무하는 TIcketOffice까지 맘대로 접근할 수 있었기때문 -> 자유도가 높음
    * 자율성을 높이자
        * Theater는 TicketSeller의 sellTo()라는 인터페이스에만 의존하도록해서, Theater가 TicketOffice를 몰라도 되도록 캡슐화
        * TicketSeller가 Audience의 Bag을 몰라도 되도록 Audience의 buy()메소드를 추가, buy()내에서 Audience가 초대장 소유 여부를 ‘직접’판단해서 지불할 금액을 리턴하도록 함
        * Bag이 캡슐화되고, Audience스스로 문제를 해결할 수 있도록 자율성을 높임
    * 응집도
        * 밀접하게 연관된 작업만을 수행하고, 연관성이 없는 작업은 다른 객체에게 위임 -> 응집도가 높다
    * 절차지향 vs 객체지향
        * 절차지향
            * enter메소드
                * 메소드 자체가 프로세스임
                * Audience, TicketSeller, Bag, TicketOffice는 데이터일 뿐
                * Theater가 전체적인 프로세스를 도맡아 처리 -> 독재자
                * 프로세스와 데이터를 서로 다른 모듈에 위치 시킴 -> 절차지향적
            * 가장 큰 문제
                * 데이터변경으로 인한 영향을 지역적으로 고립시키기 어렵다
                * Audience와 TicketSeller의 내부구현 변경-> Theater의 enter메서드를 함께 변경해야만
                * 여러군대 변경은 버그를 부르고, 버그가 두려워 변경을 어렵게 만듬
                * 결론 > 절차적 프로그래밍은 변경하기 어려운 코드를 양산하는 경향이 있다
        * 객체지향
            * 변경하기 쉬운 설계 = 한 번에 하나의 클래스만 변경할 수 있는 설계
            * 방법? 자신의 데이터를 스스로 처리하도록
            * 데이터와 프로세스가 동일모듈(class)내에 위치하도록
            * 캡슐화를 이용해 의존성을 적절히 관리 -> 객체 사이의 결합도를 낮추는 것 -> 유연하다는 것
* (step3) 두번째 개선
    * 가방속의 Invitation과 Ticket은 Bag의 데이터이고, Invitation이 존재하는지 체크해서 TIcket을 넣고 빼는 일련의 비지니스는 Bag이 책임져야
    * 매표소의 티켓들과 Amount는 매표소의 것, 티켓을 하나 빼는 것과 지불받은 티켓값을 더하는 행위의 책임은 판매원이 아닌 매표소의 책임범위임
* 객체지향 설계
    * 설계란 코드를 배치하는 것이다
    * 오늘까지 완성해야할 기능을 구현하는 코드를 짜야하는 동시에 + 내일 쉽게 변경할 수 있는 코드를 짜야한다
    * 요구사항은 ‘항상’ 변경된다.
        * 개발 시작 시점에 ‘모든’ 요구사항을 수집하는 건 불가능
    * 우리가 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드다
    * 변경가능한 코드 = 이해하기 쉬운 코드

## 2장. 객체지향프로그래밍
* 클래스가 아닌 객체에 초점을 맞춰야
    * 어떤 클래스가 필요한지 이전에 어떤 객체들이 필요한지 고민하라
        * 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야
    * 객체를 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야
* 도메인
    * 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
* 가시성
    * public or private
* ‘자율’적인 객체
    * 캡슐화 : 데이터와 기능을 객체 내부로 함께 묶는 것
* 인터페이스와 구현의 분리 (separation of interface and implementation)
    * 외부에서 접근가능한 부분 -> 퍼블릭 인터페이스 (public interface)
    * 오직 내부에서만 접근이 가능한 부분 -> 구현 (implementation)
* 예) 엔진을 교체해도 운전하는 방법을 새로 익힐필요가 없다
* 하나의 인스턴스 변수만을 포함하더라도 개념을 명시적으로 표현할 수 있는게 중요
    * Money클래스
* 협력 (collaboration)
    * 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용
* 메소드를 호출한다 => 메시지를 전송한다
* 템플릿 메소드 패턴
    * 부모클래스에 기본적인 알고리즘 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에 위임하는 디자인패턴
* 차이에 의한 프로그래밍 (programming by difference)
* 메시지와 메소드
    * 메시지 -> interface
    * 메소드 -> 구현체의 실제 method
    * 어떤 메소드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 달림 -> 다형성
    * 다형성
        * 동일 메시지를 수신했을 때
        * 객체의 타입에 따라 다르게 응답할 수 있는 능력
* 코드 재사용
    * 상속보다는 합성(composition)
    * 합성
        * 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법
    * 상속의 문제
        * 캡슐화를 위반
            * 부모 클래스의 내부 구조를 잘 알고 있어야
            * 자식클래스가 부모클래스에 강하게 결합되도록 만들어짐
                * 부모클래스가 변경될 때 자식클래스도 변경될 가능성이 높아짐
        * 컴파일 시점에 관계가 결정됨
    * 합성
        * Movie가 DiscountPolicy의 인터페이스를 통해 약하게 결합됨
        * 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법
            * 구현을 효과적으로 캡슐화 가능
            * 의존하는 인스턴스를 교체하는 것이 비교적 용이 -> 유연 -> 느슨한 결합
## 3장. 역할,책임,협력
1. 협력
2. 책임
    * 하는 것
    * 아는 것
    * 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것
    * CRC카드
        * Class -> Component -> Role -> Candidate
        * Responsibility
        * Collaboration
    * 책임할당
        * Information expert 패턴
        * 예매하라부터 시작해보자
            * 예매하려면 무엇을 알아야하는가? -> 상영시간과 기본요금을 알아야 -> 그건 누가 가장 잘 아는데? -> Screening이 전문가임돠 -> 예매하라라는 메시지를 Screening에게 전하면 됨
            * 그런데! 예매가격을 알려면 가격을 가장 잘 알고 있는 전문가가 필요 -> 그건 movie가 전문가임돠 -> 가격을 계산하라라는 메시지를 Movie에 전하면 됨
            * 그런데! 할인요금을 알아야하는데? -> 그건 DiscountPolicy가 전문가임돠 -> 할인가격을 알려다오라고 메시지를 전하면 됨
        * 이렇게 결정된 메시지가 객체의 퍼블릭 인터페이스를 구성한다
    * 책임주도설계 Responsibility-Driven Design, RDD
    * 메시지가 객체를 결정한다
        * 필요한 메시지를 먼저 식별 -> 메시지를 처리할 객체를 나중에 선택하는 방식으로
        * 최소한의 인터페이스를 가질 수 있음
        * 충분히 추상적인 인터페이스를 가질 수 있음
            * 인터페이스는
                * 무엇(what)을 하는지 표현해야
                * 어떻게(how)를 수행하는지를 노출해서는 안됨
    * 행동이 상태를 결정한다
        * 객체의 존재이유 -> 협력에 참여하기 위해
        * 객체의 행동 -> 협력에 참여할 유일한 방법
        * 초보의 실수
            * 행동이 아닌 상태에 초점을 맞춤 -> 데이터 주도 설계가 되어버림
3. 역할
    * 특정한 협력 안에서 수행하는 책임의 집합
    * DiscountPolicy가 ‘역할’부분임
    * 역할을 구현하는 방법
        * 추상클래스
        * 인터페이스
    *  collaboration —(reference) —> role —(select from) —> object —(instance of) —> class
